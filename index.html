<!doctype html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>reveal.js</title>

    <link rel="stylesheet" href="css/reset.css">
    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/solarized.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/monokai.css">

    <!-- Printing and PDF exports -->
    <script>
        var link = document.createElement('link');
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
        document.getElementsByTagName('head')[0].appendChild(link);
    </script>
</head>

<body>
    <div class="reveal">
        <div class="slides">
            <section>
                <h2>Declarative concurrency with ZIO STM</h2>
            </section>
            <section>
                <h3>About me</h3>
                <ul>
                    <li>@dejan_mijic</li>
                    <li>Software engineer @ Zalando SE</li>
                    <li>OSS contributor</li>
                    <li>Trivia collector</li>
                </ul>
            </section>
            <section>
                <h3>Concurrency is terrible</h3>
                <ul>
                    <li class="fragment">Race conditions</li>
                    <li class="fragment">Deadlocks</li>
                    <li class="fragment">Contention</li>
                    <li class="fragment">Composability</li>
                    <li class="fragment">...</li>
                </ul>
            </section>
            <section data-background="/images/boom.gif">
            </section>
            <section>
                <h3>Software transactional memory</h3>
            </section>
            <section>
                <h3>Basic idea</h3>
                <ul>
                    <li class="fragment">accumulate transaction log</li>
                    <li class="fragment">rollback failures</li>
                    <li class="fragment">retry when not ready</li>
                    <li class="fragment">commit otherwise</li>
                </ul>
            </section>

            <section>
                <section>
                    <h3>Building blocks</h3>
                </section>
                <section>
                    <h3>TRef</h3>
                    <pre><code class="hljs scala" data-trim>
                    trait TRef[A] {
                      val get: STM[Nothing, A]
                      def set(newValue: A): STM[Nothing, Unit]
                      def update(f: A => A): STM[Nothing, A]
                      def modify[B](f: A => (B, A)): STM[Nothing, B]
                    }

                    object TRef {
                      def make[A](a: A): STM[Nothing, TRef[A]]
                    }
                    </code></pre>
                </section>
                <section>
                    <h3>STM[E, A]</h3>
                    <ul>
                        <li>fails with error E</li>
                        <li>succeeds with value A</li>
                    </ul>
                </section>
                <section>
                    <h3>STM - succeed & fail</h3>
                    <pre><code class="hljs scala" data-trim>
                    object STM {
                      def fail[E](e: E): STM[E, Nothing]
                      def succeed[A](a: A): STM[Nothing, A]
                    }

                    val success = STM.succeed("Hello!")
                    val failure = STM.fail("Nothing to see here...")
                    </code></pre>
                </section>
                <section>
                    <h3>STM - chaining</h3>
                    <pre><code class="hljs scala" data-trim>
                    trait STM[E, A] {
                      def map[B](f: A => B): STM[E, B]
                      def flatMap[E1 >: E, B](f: A => STM[E1, B]): STM[E1, B]
                    }

                    val sum: STM[Nothing, Long] =
                      for {
                        a <- account1.get
                        b <- account2.get
                      } yield a + b
                    </code></pre>
                </section>
                <section>
                    <h3>STM - zipping</h3>
                    <pre><code class="hljs scala" data-trim>
                    trait STM[E, A] {
                      def zip[E1 >: E, B](that: => STM[E1, B]): STM[E1, (A, B)]
                    }

                    val bothAccounts: STM[Nothing, (Long, Long)] =
                      account1.get zip account2.get
                </code></pre>
                </section>
                <section>
                    <h3>STM - folds</h3>
                    <pre><code class="hljs scala" data-trim>
                    trait STM[E, A] {
                      def fold[B](f: E => B, g: A => B): STM[Nothing, B]

                      def foldM[E1, B](f: E => STM[E1, B],
                                       g: A => STM[E1, B]): STM[E1, B]
                    }

                    val recovered: STM[Nothing, Boolean] =
                      failure.fold(_ => false, _ => true)
                    </code></pre>
                </section>
                <section>
                    <h3>STM - check & retry</h3>
                    <pre><code class="hljs scala" data-trim>
                    object STM {
                      val retry: STM[Nothing, Nothing]

                      final def check(p: Boolean): STM[Nothing, Unit] =
                        if (p) STM.unit else retry
                    }
                    </code></pre>
                </section>
                <section>
                    <h3>STM - alternative</h3>
                    <pre><code class="hljs scala" data-trim>
                    trait STM[E, A] {
                      def orElse[E1, A1 >: A](that: => STM[E1, A1]): STM[E1, A1]
                    }

                    STM.fail("failure") orElse STM.succeed(1)
                    </code></pre>
                </section>
                <section>
                    <h3>STM - commit</h3>
                    <pre><code class="hljs scala" data-trim>
                    trait STM[E, A] {
                      def commit: IO[E, A] = STM.atomically(this)
                    }

                    object STM {
                      def atomically[E, A](stm: STM[E, A]): IO[E, A]
                    }
                    </code></pre>
                </section>
            </section>

            <section>
                <h3>Example</h3>
            </section>

            <section>
                <section>
                    <h3>Data structures</h3>
                </section>
                <section>
                    <h3>TPromise</h3>
                    <pre><code class="hljs scala" data-trim>
                    trait TPromise[E, A] {
                      def await: STM[E, A]
                      def done(v: Either[E, A]): STM[Nothing, Boolean]
                      def fail(e: E): STM[Nothing, Boolean]
                      def poll: STM[Nothing, Option[STM[E, A]]]
                      def succeed(a: A): STM[Nothing, Boolean]
                    }

                    object TPromise {
                      def make[E, A]: STM[Nothing, TPromise[E, A]]
                    }
                    </code></pre>
                </section>
                <section>
                    <h3>TSemaphore</h3>
                    <pre><code class="hljs scala" data-trim>
                    trait TSemaphore {
                      def acquire: STM[Nothing, Unit]
                      def acquireN(n: Long): STM[Nothing, Unit]
                      def available: STM[Nothing, Long]
                      def release: STM[Nothing, Unit]
                      def releaseN(n: Long): STM[Nothing, Unit]
                      def withPermit[E, B](stm: STM[E, B]): STM[E, B]
                    }

                    object TSemaphore {
                      def make(n: Long): STM[Nothing, TSemaphore]
                    }
                    </code></pre>
                </section>
                <section>
                    <h3>TQueue</h3>
                    <pre><code class="hljs scala" data-trim>
                    trait TQueue[A] {
                      def offer(a: A): STM[Nothing, Unit]
                      def offerAll(as: List[A]): STM[Nothing, Unit]
                      def poll: STM[Nothing, Option[A]]
                      def size: STM[Nothing, Int]
                      def take: STM[Nothing, A]
                      def takeAll: STM[Nothing, List[A]]
                      def takeUpTo(max: Int): STM[Nothing, List[A]]
                    }

                    object TQueue {
                      def make[A](capacity: Int): STM[Nothing, TQueue[A]]
                    }
                    </code></pre>
                </section>
                <section>
                    <h3>TArray - creation</h3>
                    <pre><code class="hljs scala" data-trim>
                    object TArray {
                      def make[A](data: A*): STM[Nothing, TArray[A]]
                      def empty[A]: STM[Nothing, TArray[A]]
                      def fromIterable[A](data: Iterable[A]): STM[Nothing, TArray[A]]
                    }
                    </code></pre>
                </section>
                <section>
                    <h3>TArray - read & write</h3>
                    <pre><code class="hljs scala" data-trim>
                    trait TArray[A] {
                      def apply(index: Int): STM[Nothing, A]
                      def update(index: Int, fn: A => A): STM[Nothing, A]
                      def updateM[E](index: Int, fn: A => STM[E, A]): STM[E, A]
                    }
                    </code></pre>
                </section>
                <section>
                    <h3>TArray - transformations</h3>
                    <pre><code class="hljs scala" data-trim>
                    trait TArray[A] {
                      def transform(f: A => A): STM[Nothing, Unit]
                      def transformM[E](f: A => STM[E, A]): STM[E, Unit]
                    }
                    </code></pre>
                </section>
                <section>
                    <h3>TArray - folds</h3>
                    <pre><code class="hljs scala" data-trim>
                    trait TArray[A] {
                      def fold[Z](acc: Z)(op: (Z, A) => Z): STM[Nothing, Z]
                      def foldM[E, Z](acc: Z)(op: (Z, A) => STM[E, Z]): STM[E, Z]
                    }
                    </code></pre>
                </section>
                <section>
                    <h3>TMap - creation</h3>
                    <pre><code class="hljs scala" data-trim>
                    object TMap {
                      def make[K, V](data: (K, V)*): STM[Nothing, TMap[K, V]]
                      def empty[K, V]: STM[Nothing, TMap[K, V]]
                      def fromIterable[K, V](data: Iterable[(K, V)]): STM[Nothing, TMap[K, V]]
                    }
                    </code></pre>
                </section>
                <section>
                    <h3>TMap - read & write</h3>
                    <pre><code class="hljs scala" data-trim>
                    trait TMap[K, V] {
                      def contains(k: K): STM[Nothing, Boolean]
                      def delete(k: K): STM[Nothing, Unit]
                      def get(k: K): STM[Nothing, Option[V]]
                      def getOrElse(k: K, default: => V): STM[Nothing, V]
                      def put(k: K, v: V): STM[Nothing, Unit]
                      def merge(k: K, v: V)(f: (V, V) => V): STM[Nothing, V]
                    }
                    </code></pre>
                </section>
                <section>
                    <h3>TMap - transformations</h3>
                    <pre><code class="hljs scala" data-trim>
                    trait TMap[K, V] {
                      def removeIf(p: (K, V) => Boolean): STM[Nothing, Unit]
                      def retainIf(p: (K, V) => Boolean): STM[Nothing, Unit]
                      def transform(f: (K, V) => (K, V)): STM[Nothing, Unit]
                      def transformM[E](f: (K, V) => STM[E, (K, V)]): STM[E, Unit]
                      def transformValues(f: V => V): STM[Nothing, Unit]
                      def transformValuesM[E](f: V => STM[E, V]): STM[E, Unit]
                    }
                    </code></pre>
                </section>
                <section>
                    <h3>TMap - folds</h3>
                    <pre><code class="hljs scala" data-trim>
                    trait TMap[K, V] {
                      def fold[A](zero: A)(op: (A, (K, V)) => A): STM[Nothing, A]
                      def foldM[A, E](zero: A)(op: (A, (K, V)) => STM[E, A]): STM[E, A]
                    }
                    </code></pre>
                </section>
                <section>
                    <h3>TSet - creation</h3>
                    <pre><code class="hljs scala" data-trim>
                    object TSet {
                      def make[A](data: A*): STM[Nothing, TSet[A]]
                      def empty[A]: STM[Nothing, TSet[A]]
                      def fromIterable[A](data: Iterable[A]): STM[Nothing, TSet[A]]
                    }
                    </code></pre>
                </section>
                <section>
                    <h3>TSet - read & write</h3>
                    <pre><code class="hljs scala" data-trim>
                    trait TSet[A] {
                      def contains(a: A): STM[Nothing, Boolean]
                      def delete(a: A): STM[Nothing, Unit]
                      def put(a: A): STM[Nothing, Unit]
                    }
                    </code></pre>
                </section>
                <section>
                    <h3>TSet - transformations</h3>
                    <pre><code class="hljs scala" data-trim>
                    trait TSet[A] {
                      def diff(other: TSet[A]): STM[Nothing, Unit]
                      def intersect(other: TSet[A]): STM[Nothing, Unit]
                      def removeIf(p: A => Boolean): STM[Nothing, Unit]
                      def retainIf(p: A => Boolean): STM[Nothing, Unit]
                      def transform(f: A => A): STM[Nothing, Unit]
                      def transformM[E](f: A => STM[E, A]): STM[E, Unit]
                      def union(other: TSet[A]): STM[Nothing, Unit]
                    }
                    </code></pre>
                </section>
                <section>
                    <h3>TSet - folds</h3>
                    <pre><code class="hljs scala" data-trim>
                    trait TSet[A] {
                      def fold[B](zero: B)(op: (B, A) => B): STM[Nothing, B]
                      def foldM[B, E](zero: B)(op: (B, A) => STM[E, B]): STM[E, B]
                    }
                    </code></pre>
                </section>
            </section>

            <section>
                <h3>Improvements</h3>
                <ul>
                    <li>Stack safety [WIP]</li>
                    <li>Documentation [WIP]</li>
                    <li>Performance</li>
                    <li>Finalizers</li>
                </ul>
            </section>

            <section>
                <h3>Learn more</h3>
                <ul>
                    <li>"Composable memory transactions" by T. Harris et al.</li>
                    <li>"Lock Free Data Structures using STMs in Haskell" by A. Discolo et al.</li>
                </ul>
            </section>

            <section>
                <h3>Call for participation</h3>
                <ul>
                    <li>https://github.com/zio/zio</li>
                    <li>https://discord.gg/2ccFBr4</li>
                </ul>
            </section>

            <section>
                <h3>Thank you!</h3>
            </section>
        </div>
    </div>

    <script src="js/reveal.js"></script>

    <script>
        // More info about config & dependencies:
        // - https://github.com/hakimel/reveal.js#configuration
        // - https://github.com/hakimel/reveal.js#dependencies
        Reveal.initialize({
            dependencies: [{
                    src: 'plugin/markdown/marked.js'
                },
                {
                    src: 'plugin/markdown/markdown.js'
                },
                {
                    src: 'plugin/notes/notes.js',
                    async: true
                },
                {
                    src: 'plugin/highlight/highlight.js',
                    async: true
                }
            ]
        });
    </script>
</body>

</html>
